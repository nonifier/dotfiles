#! /bin/bash

#generate_nav_from() {
#    ED_BUILD_PATH="$_NAVITIA_BUILD_DIR_/ed/"
#    COVERAGE_PATH=$(realpath .)
#
#    if [[ $1 ]]; then NAVITIA_PATH=$(realpath $1); fi
#    if [[ $2 ]]; then ED_BUILD_PATH=$(realpath $2); fi
#    if [[ $3 ]]; then COVERAGE_PATH=$(realpath $3); fi
#
#	echo "NAVITIA_PATH=$NAVITIA_PATH"
#	echo "ED_BUILD_PATH=$ED_BUILD_PATH"
#	echo "COVERAGE_PATH=$COVERAGE_PATH"
#
#    pushd "$NAVITIA_PATH/source/eitri"
#        virtual_env_workon_or_create eitri requirements.txt
#            EITRI_CMD="python eitri.py -d $COVERAGE_PATH -o $COVERAGE_PATH/data.nav.lz4 -e $ED_BUILD_PATH"
#            echo $EITRI_CMD
#            $($EITRI_CMD)
#        deactivate
#    popd
#}
#
#generate_nav_from_bdd() {
#    local COVERAGE=$1
#    local PASSWD=$2
#    local HOST=$3
#    local CITIES_USER=$4
#    local CITIES_PWD=$5
#
#    if [[ $# -lt 2 ]]; then
#        echo "usage:"
#        echo "      generate_nav_from_bdd <COVERAGE> <PWD> <HOST> <CITIES_USER> <CITIES_PWD>"
#        echo ""
#        echo "Environment Variables :"
#        echo "    NAVITIA_BUILD_DIR : path to Kraken Binary"
#        echo ''
#        return 0
#    fi
#    if [[ ! $NAVITIA_BUILD_DIR ]]; then
#        NAVITIA_BUILD_DIR=$_NAVITIA_BUILD_DIR_;
#    fi
#
#    CONNECTION_STR="postgresql://$COVERAGE:$PASSWD@$HOST/$COVERAGE"
#    CITIES_STR="postgresql://$CITIES_USER:$CITIES_PWD@$HOST/cities"
#    echo "- connection string : $CONNECTION_STR"
#    echo "- cities string : $CITIES_STR"
#    echo "- Kraken build dir : $NAVITIA_BUILD_DIR";
#    local ED_CMD="$NAVITIA_BUILD_DIR/ed/ed2nav -o "./data.nav.lz4" --connection-string $CONNECTION_STR --cities-connection-string $CITIES_STR"
#    echo "- $ED_CMD"
#    eval $ED_CMD
#}
#
#
#
#navitia_print_rt_base64_protobuf() {
#    pushd "$NAVITIA_SRC_PATH/jormungandr/tests" > /dev/null
#        virtual_env_workon_or_create jormun ../requirements_dev.txt > /dev/null
#            python -c "
#import gtfs_realtime_pb2
#fm = gtfs_realtime_pb2.FeedMessage()
#
#from base64 import b64decode
#fm.ParseFromString(b64decode(u'$1'))
#
#from google.protobuf import text_format, json_format
#print(json_format.MessageToJson(fm))
#"
#        deactivate
#    popd > /dev/null
#}
#
#__load_file_if_exists ~/dev/kisio/source/navitia-configurator/bash-tools/tyr.sh # Navitia

tyr_jobs_data_sets_view() {
    jq -r '.jobs[] | . as $j | .data_sets[] + $j | [.id, .instance.name, .type, .family_type, .state, .created_at, .updated_at ] | @tsv ' | column -t
}

tyr_jobs_metrics_view() {
    jq -r '.jobs[] | . as $j | .metrics[] + $j | [ .id, .state, .instance.name, .type, .duration, .created_at, .updated_at] | @tsv ' | column -t
}

navitia_url() {
    if [[ -z "$1" ]]; then
        echo "Usage: navitia_url { sand[box] | c[us[tomer]] | p[rod[uction]] }" 1>&2
        return 1
    fi

    local platform=$(pass pro/hove/playground.navitia.io | grep -o ".*$1.*: ")

    if [[ -z "$platform" ]]; then
        echo "Platform not found with pattern: $1"
        return 2
    fi

    if [[ $(wc -l <<<"$platform") -gt "1" ]]; then
        echo "Multiple platforms found using pattern - \"$1\" :"
        echo "$platform"
        return 2
    fi

    pass pro/hove/playground.navitia.io | grep "$platform" | sed "s/${platform}//"
}

navitia_coverages() {
    http --verify=no "$1/v1/coverage" | jq -r '.regions[].id'
}

navitia_jormungandr_version() {
    http --verify=no "$1/v1/status" | jq -r '.jormungandr_version'
}

navitia_kraken_version() {
    http --verify=no "$1/v1/coverage/$2/status" | jq -r '.status.kraken_version'
}

navitia_versions() {
    local url
    url="$(navitia_url "$1")"

    echo "-- Platform Navitia No Coverage --"
    echo "Jormun $(navitia_jormungandr_version "$url")"

    echo "-- Kraken Versions --"
    for c in $(navitia_coverages "$url"); do
        echo "$c $(navitia_kraken_version "$url" "$c")" | column -t
    done
}
